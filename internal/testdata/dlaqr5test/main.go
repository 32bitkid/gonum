// Copyright Â©2016 The gonum Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This program generates test data for Dlaqr5. Test cases are stored as text
// files inside dlaqr5data.zip archive which is then read by testlapack/dlaqr5.go.
//
// This program uses cgo to call Fortran version of DLAQR5. Therefore, matrices
// generated by hessrand and eye are in column-major format but are written into
// test case files in row-major format. See writeCase and writeCaseWant for
// details.
package main

// void dlaqr5_(int* wantt, int* wantz, int* kacc22, int* n, int* ktop, int* kbot, int* nshfts,
//              double* sr, double* si, double* h, int* ldh, int* iloz, int* ihiz,
//              double* z, int* ldz, double* v, int* ldv, double* u, int* ldu,
//              int* nv, double* wv, int* ldwv, int* nh, double* wh, int* ldwh);
import "C"

import (
	"archive/zip"
	"fmt"
	"io"
	"log"
	"math/rand"
	"os"
)

func fortranDlaqr5(wantt, wantz bool, kacc22 int, n, ktop, kbot int, nshfts int, sr, si []float64, h []float64,
	ldh int, iloz, ihiz int, z []float64, ldz int, v []float64, ldv int,
	u []float64, ldu int, nh int, wh []float64, ldwh int, nv int, wv []float64, ldwv int) {
	func() {
		wt := C.int(0)
		if wantt {
			wt = 1
		}
		wz := C.int(0)
		if wantz {
			wz = 1
		}
		kacc22 := C.int(kacc22)
		n := C.int(n)
		ktop := C.int(ktop + 1)
		kbot := C.int(kbot + 1)
		nshfts := C.int(nshfts)
		ldh := C.int(ldh)
		iloz := C.int(iloz + 1)
		ihiz := C.int(ihiz + 1)
		ldz := C.int(ldz)
		ldv := C.int(ldv)
		ldu := C.int(ldu)
		nh := C.int(nh)
		ldwh := C.int(ldwh)
		nv := C.int(nv)
		ldwv := C.int(ldwv)
		C.dlaqr5_((*C.int)(&wt), (*C.int)(&wz), (*C.int)(&kacc22),
			(*C.int)(&n), (*C.int)(&ktop), (*C.int)(&kbot),
			(*C.int)(&nshfts), (*C.double)(&sr[0]), (*C.double)(&si[0]),
			(*C.double)(&h[0]), (*C.int)(&ldh),
			(*C.int)(&iloz), (*C.int)(&ihiz), (*C.double)(&z[0]), (*C.int)(&ldz),
			(*C.double)(&v[0]), (*C.int)(&ldv),
			(*C.double)(&u[0]), (*C.int)(&ldu),
			(*C.int)(&nh), (*C.double)(&wh[0]), (*C.int)(&ldwh),
			(*C.int)(&nv), (*C.double)(&wv[0]), (*C.int)(&ldwv))
	}()
}

func main() {
	const tmpl = "wantt%v_n%v_nshfts%v_ktop%v_kbot%v.txt"

	file, err := os.Create("dlaqr5data.zip")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()
	zipfile := zip.NewWriter(file)

	rnd := rand.New(rand.NewSource(1))

	for _, wantt := range []bool{true, false} {
		for _, n := range []int{2, 3, 4, 5, 6, 7, 11} {
			for k := 0; k <= min(5, n); k++ {
				npairs := k
				if npairs == 0 {
					npairs = 2 * n
				}
				for ktop := 0; ktop < n-1; ktop++ {
					for kbot := ktop + 1; kbot < n; kbot++ {
						sr, si := shiftpairs(npairs, rnd)
						nshfts := len(sr)

						v := make([]float64, nshfts/2*3)
						u := make([]float64, (3*nshfts-3)*(3*nshfts-3))
						nh := n
						wh := make([]float64, (3*nshfts-3)*n)
						nv := n
						wv := make([]float64, n*(3*nshfts-3))

						z := eye(n)
						h := hessrand(n, rnd)
						if ktop > 0 {
							h[ktop+(ktop-1)*n] = 0
						}
						if kbot < n-1 {
							h[kbot+1+kbot*n] = 0
						}

						w, err := zipfile.Create(fmt.Sprintf(tmpl, wantt, n, nshfts, ktop, kbot))
						if err != nil {
							log.Fatal(err)
						}
						writeCase(w, wantt, n, nshfts, ktop, kbot, sr, si, h)
						fortranDlaqr5(wantt, true, 2,
							n, ktop, kbot,
							nshfts, sr, si,
							h, n,
							0, n-1, z, n,
							v, 3,
							u, 3*nshfts-3,
							nh, wh, nh,
							nv, wv, 3*nshfts-3)
						writeCaseWant(w, n, h, z)
					}
				}
			}
		}
	}

	err = zipfile.Close()
	if err != nil {
		log.Fatal(err)
	}
}

// eye returns an identity matrix of order n.
func eye(n int) []float64 {
	m := make([]float64, n*n)
	for i := 0; i < n*n; i += n + 1 {
		m[i] = 1
	}
	return m
}

// hessrand returns a Hessenberg matrix of order n with random non-zero entries
// in column-major format.
func hessrand(n int, rnd *rand.Rand) []float64 {
	h := make([]float64, n*n)
	for j := 0; j < n; j++ {
		for i := 0; i <= min(j+1, n-1); i++ {
			h[i+j*n] = rnd.NormFloat64()
		}
	}
	return h
}

// shiftpairs generates k real and complex conjugate shift pairs. That is, the
// length of sr and si is 2*k.
func shiftpairs(k int, rnd *rand.Rand) (sr, si []float64) {
	sr = make([]float64, 2*k)
	si = make([]float64, 2*k)
	for i := 0; i < len(sr); {
		if rnd.Float64() < 0.5 || i == len(sr)-1 {
			sr[i] = rnd.NormFloat64()
			i++
			continue
		}
		// Generate a complex conjugate pair.
		r := rnd.NormFloat64()
		c := rnd.NormFloat64()
		sr[i] = r
		si[i] = c
		sr[i+1] = r
		si[i+1] = -c
		i += 2
	}
	return sr, si
}

// writeCase writes into w given data with one value per line. h is assumed in
// column-major order and is written in row-major.
func writeCase(w io.Writer, wantt bool, n, nshfts, ktop, kbot int, sr, si, h []float64) {
	fmt.Fprintln(w, wantt, n, nshfts, ktop, kbot)
	for _, v := range sr {
		fmt.Fprintln(w, v)
	}
	for _, v := range si {
		fmt.Fprintln(w, v)
	}
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			fmt.Fprintln(w, h[i+j*n])
		}
	}
}

// writeCaseWant writes into w given data with one value per line. h and z are
// assumed in column-major order and are written in row-major.
func writeCaseWant(w io.Writer, n int, h, z []float64) {
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			fmt.Fprintln(w, h[i+j*n])
		}
	}
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			fmt.Fprintln(w, z[i+j*n])
		}
	}
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
